<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PROJECT_2026: AETHER_MEMORY</title>
    <style>
        /* --- 核心环境设置 --- */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #050505; overflow: hidden; font-family: 'Consolas', 'Monaco', monospace; }
        
        /* --- 容器层级 --- */
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

        /* --- 1. 视频底层 (增强质感) --- */
        #video-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: 1;
            opacity: 0; transform: scale(1.1); transition: all 2s cubic-bezier(0.19, 1, 0.22, 1);
            filter: contrast(1.2) saturation(1.1) brightness(0.9);
        }

        /* --- 2. CRT 扫描线滤镜层 --- */
        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 4px, 6px 100%;
            pointer-events: none;
        }

        /* --- 3. 晕映 (Vignette) --- */
        .vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 6;
            background: radial-gradient(circle, rgba(0,0,0,0) 60%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
        }

        /* --- 4. 粒子画布 (交互层) --- */
        canvas { position: absolute; top: 0; left: 0; z-index: 10; mix-blend-mode: screen; pointer-events: none;}

        /* --- 5. UI 界面层 --- */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; transition: opacity 0.8s;
            backdrop-filter: blur(5px);
        }

        /* 启动按钮设计 */
        .start-btn {
            border: 1px solid rgba(255,255,255,0.3); padding: 20px 40px;
            font-size: 14px; letter-spacing: 4px; cursor: pointer;
            background: rgba(0,0,0,0.4); text-transform: uppercase;
            transition: all 0.3s; position: relative; overflow: hidden;
        }
        .start-btn:hover { background: #fff; color: #000; box-shadow: 0 0 20px rgba(255,255,255,0.5); }
        .start-btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.8), transparent);
            transition: 0.5s;
        }
        .start-btn:hover::before { left: 100%; }

        /* 动态文字与歌词 */
        #subtitles {
            position: absolute; bottom: 10%; width: 100%; text-align: center; z-index: 20;
            font-size: 1.5rem; color: rgba(255,255,255,0.9); font-weight: 300; letter-spacing: 8px;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
            font-family: 'Arial', sans-serif; opacity: 0; transition: opacity 0.5s;
            mix-blend-mode: overlay;
        }

        /* 故障动画类 */
        .glitch-active {
            animation: glitch-anim 0.3s cubic-bezier(.25, .46, .45, .94) both infinite;
            color: #ff00ff;
        }
        @keyframes glitch-anim {
            0% { transform: translate(0) }
            20% { transform: translate(-2px, 2px) }
            40% { transform: translate(-2px, -2px) }
            60% { transform: translate(2px, 2px) }
            80% { transform: translate(2px, -2px) }
            100% { transform: translate(0) }
        }

        /* 电影黑边 (Cinematic Bars) */
        .cinematic-bar {
            position: absolute; left: 0; width: 100%; height: 0; background: black; z-index: 90;
            transition: height 1.5s ease-in-out;
        }
        .bar-top { top: 0; }
        .bar-bottom { bottom: 0; }
        
        .playing .cinematic-bar { height: 10vh; } /* 播放时压黑边 */

    </style>
</head>
<body>

    <div id="container">
        <video id="video-layer" loop playsinline preload="auto">
            <source src="Video_1767191314000_2.mp4" type="video/mp4">
        </video>

        <div class="scanlines"></div>
        <div class="vignette"></div>
        
        <div class="cinematic-bar bar-top"></div>
        <div class="cinematic-bar bar-bottom"></div>

        <canvas id="canvas"></canvas>

        <div id="subtitles"></div>

        <div id="ui-layer">
            <div style="font-size: 12px; margin-bottom: 20px; color: #888;">SYSTEM_READY // 2026_PROTOCOL</div>
            <div class="start-btn" onclick="initializeSystem()">
                [ Initialize Memories ]
            </div>
        </div>
    </div>

    <script>
        // --- 系统配置 ---
        const config = {
            particleCount: 150,
            connectionDist: 100,
            baseColor: { h: 200, s: 80, l: 60 }, // 基础冷色调
            activeColor: { h: 320, s: 100, l: 70 } // 激活时的粉色调（呼应视频）
        };

        const ui = document.getElementById('ui-layer');
        const video = document.getElementById('video-layer');
        const subtitleEl = document.getElementById('subtitles');
        const container = document.getElementById('container');

        // --- 核心启动逻辑 ---
        function initializeSystem() {
            // 1. UI 消失
            ui.style.opacity = 0;
            setTimeout(() => ui.style.display = 'none', 800);

            // 2. 视频启动
            video.play().then(() => {
                video.muted = false; // 尝试开启声音
                video.style.opacity = 1;
                video.style.transform = "scale(1)"; // 缩放复位动画
                container.classList.add('playing'); // 触发电影黑边
            }).catch(e => console.error("Video Error:", e));

            // 3. 启动特效循环
            initParticles();
            startSubtitleSequence();
            
            // 4. 随机故障震动效果 (模拟记忆不稳定)
            setInterval(randomGlitch, 4000);
        }

        function randomGlitch() {
            if(Math.random() > 0.7) {
                // 瞬间色散
                video.style.filter = "contrast(1.5) hue-rotate(90deg) blur(2px)";
                video.style.transform = "scale(1.02) translateX(5px)";
                setTimeout(() => {
                    video.style.filter = "contrast(1.2) saturation(1.1) brightness(0.9)";
                    video.style.transform = "scale(1)";
                }, 100);
            }
        }

        // --- 字幕序列系统 ---
        function startSubtitleSequence() {
            const lines = [
                "RECONSTRUCTING...",
                "TIMELINE: 2025 -> 2026",
                "MEMORY FRAGMENTS FOUND",
                "I WILL ALWAYS FIND YOU",
                "THE FUTURE IS BRIGHT",
                "HAPPY NEW YEAR"
            ];
            
            let index = 0;
            
            function nextLine() {
                // 淡出
                subtitleEl.style.opacity = 0;
                subtitleEl.style.transform = "translateY(10px) scale(0.9)";
                
                setTimeout(() => {
                    // 更新文字并淡入
                    if(index < lines.length) {
                        subtitleEl.innerText = lines[index];
                        subtitleEl.style.opacity = 1;
                        subtitleEl.style.transform = "translateY(0) scale(1)";
                        subtitleEl.style.letterSpacing = (Math.random() * 10 + 2) + "px"; // 随机字间距特效
                        index++;
                    } else {
                        index = 0; // 循环
                    }
                }, 500);
            }
            
            setInterval(nextLine, 3000);
            nextLine();
        }

        // --- 高级粒子物理系统 ---
        function initParticles() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            let w, h;
            let particles = [];
            
            // 鼠标交互
            const mouse = { x: null, y: null, active: false };
            
            window.addEventListener('resize', resize);
            window.addEventListener('mousemove', e => {
                mouse.x = e.clientX;
                mouse.y = e.clientY;
                mouse.active = true;
            });
            window.addEventListener('touchstart', e => {
                mouse.x = e.touches[0].clientX;
                mouse.y = e.touches[0].clientY;
                mouse.active = true;
            });
            
            // 定时重置鼠标状态
            setInterval(() => { mouse.active = false; }, 2000);

            function resize() {
                w = canvas.width = window.innerWidth;
                h = canvas.height = window.innerHeight;
            }
            resize();

            class Particle {
                constructor() {
                    this.x = Math.random() * w;
                    this.y = Math.random() * h;
                    this.vx = (Math.random() - 0.5) * 1.5;
                    this.vy = (Math.random() - 0.5) * 1.5;
                    this.size = Math.random() * 2;
                    this.life = Math.random() * 100;
                    // 颜色在蓝色和粉色之间随机
                    this.isPink = Math.random() > 0.5; 
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    // 边界反弹
                    if (this.x < 0 || this.x > w) this.vx *= -1;
                    if (this.y < 0 || this.y > h) this.vy *= -1;

                    // 鼠标交互（磁性吸引）
                    if (mouse.active) {
                        const dx = mouse.x - this.x;
                        const dy = mouse.y - this.y;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if (dist < 200) {
                            const forceDirectionX = dx / dist;
                            const forceDirectionY = dy / dist;
                            const force = (200 - dist) / 200;
                            const directionMultiplier = 0.05; // 吸引力度
                            this.vx += forceDirectionX * force * directionMultiplier;
                            this.vy += forceDirectionY * force * directionMultiplier;
                        }
                    }

                    // 阻尼 (防止速度过快)
                    this.vx *= 0.99;
                    this.vy *= 0.99;
                    
                    // 闪烁生命周期
                    this.life++;
                }

                draw() {
                    const opacity = (Math.sin(this.life * 0.05) + 1) / 2 * 0.8;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    
                    // 动态颜色
                    if(this.isPink) {
                        ctx.fillStyle = `rgba(255, 105, 180, ${opacity})`;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = "rgba(255, 105, 180, 0.8)";
                    } else {
                        ctx.fillStyle = `rgba(100, 200, 255, ${opacity})`;
                        ctx.shadowBlur = 5;
                        ctx.shadowColor = "rgba(100, 200, 255, 0.5)";
                    }
                    
                    ctx.fill();
                    ctx.shadowBlur = 0; // 重置以提高性能
                }
            }

            // 初始化粒子
            for (let i = 0; i < config.particleCount; i++) {
                particles.push(new Particle());
            }

            function animate() {
                ctx.clearRect(0, 0, w, h);
                
                for (let i = 0; i < particles.length; i++) {
                    particles[i].update();
                    particles[i].draw();

                    // 连线逻辑 (Neural Network Effect)
                    for (let j = i; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < config.connectionDist) {
                            ctx.beginPath();
                            const alpha = 1 - (distance / config.connectionDist);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.2})`;
                            ctx.lineWidth = 0.5;
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.stroke();
                        }
                    }
                }
                requestAnimationFrame(animate);
            }
            animate();
        }
    </script>
</body>
</html>